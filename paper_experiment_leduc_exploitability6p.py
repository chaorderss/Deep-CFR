from PokerRL.game.games import NoLimitHoldem, StandardLeduc
from PokerRL.eval.lbr import LBREvaluator
from PokerRL.eval.head_to_head import H2HEvaluator

from DeepCFR.EvalAgentDeepCFR import EvalAgentDeepCFR
from DeepCFR.TrainingProfile import TrainingProfile
from DeepCFR.workers.driver.Driver import Driver

def train_deepcfr_6players(
        game_cls=NoLimitHoldem,  # 游戏类型：可选NoLimitHoldem或StandardLeduc
        n_iterations=300,        # 训练迭代次数
        n_traversals_per_iter=3000,  # 每次迭代的树遍历次数
        mini_batch_size=2048,    # 批处理大小
        max_buffer_size=2e6,     # 最大缓冲区大小
        save_path="./models/deepcfr_6p",  # 模型保存路径
        eval_freq=10,            # 评估频率（迭代次数）
        device_id=0,             # GPU设备ID，-1表示CPU
        verbose=True,            # 是否打印详细信息
        ):
    """
    训练6人桌DeepCFR模型

    参数:
        game_cls: 游戏类，默认为无限注德州扑克
        n_iterations: 训练迭代次数
        n_traversals_per_iter: 每次迭代的树遍历次数
        mini_batch_size: 训练批次大小
        max_buffer_size: 最大经验回放缓冲区大小
        save_path: 模型保存路径
        eval_freq: 每隔多少次迭代进行一次评估
        device_id: GPU设备ID，-1表示CPU
        verbose: 是否打印详细信息

    返回:
        dict: 包含训练好的模型和评估结果的字典
    """
    # 创建6人桌游戏参数
    if game_cls == NoLimitHoldem:
        game_args = NoLimitHoldem.ARGS_CLS(
            n_seats=6,
            starting_stack_sizes_list=[10000] * 6,
            blinds_list=[50, 100, 0, 0, 0, 0],
            stack_randomization_range=(0, 0),
            use_simplified_headsup_obs=False,
            uniform_action_interpolation=False
        )
    else:  # Leduc poker
        game_args = None  # 使用默认参数，但指定6名玩家

    # 创建训练配置文件
    t_prof = TrainingProfile(
        name="DEEPCFR_6P",
        nn_type="feedforward",

        # 缓冲区设置
        max_buffer_size_adv=max_buffer_size,
        max_buffer_size_avrg=max_buffer_size,

        # 训练频率设置
        eval_agent_export_freq=eval_freq,
        checkpoint_freq=eval_freq*5,

        # 采样和训练批次
        n_traversals_per_iter=n_traversals_per_iter,
        n_batches_adv_training=int(n_traversals_per_iter/4),
        n_batches_avrg_training=int(n_traversals_per_iter*2),

        # 网络结构
        n_merge_and_table_layer_units_adv=128,
        n_merge_and_table_layer_units_avrg=128,
        n_units_final_adv=128,
        n_units_final_avrg=128,

        # 批处理大小
        mini_batch_size_adv=mini_batch_size,
        mini_batch_size_avrg=mini_batch_size,

        # 模型初始化
        init_adv_model="last",
        init_avrg_model="random",

        # 网络结构简化
        use_pre_layers_adv=True,
        use_pre_layers_avrg=True,

        # 游戏设置
        game_cls=game_cls,
        game_args=game_args,

        # 评估模式
        eval_modes_of_algo=(
            EvalAgentDeepCFR.EVAL_MODE_SINGLE,   # SD-CFR
            EvalAgentDeepCFR.EVAL_MODE_AVRG_NET, # Deep CFR
        ),

        # 设备和分布式训练
        device_id=device_id,
        DISTRIBUTED=False,

        # 日志设置
        log_verbose=verbose,
        log_memory=True,

        # 保存路径
        path_save_models=save_path,
    )

    # 设置评估方法
    eval_methods = {
        "br": 20,           # 计算对最佳响应的利用率，每20次迭代
        "h2h": 10,          # 人机对战评估，每10次迭代
    }

    # 创建训练驱动并运行
    ctrl = Driver(
        t_prof=t_prof,
        eval_methods=eval_methods,
        n_iterations=n_iterations
    )

    # 运行训练
    results = ctrl.run()

    # 返回训练结果
    return {
        "model": ctrl.eval_agent,
        "results": results,
        "exploitability": ctrl.eval_masters["br"].last_result,
        "training_profile": t_prof
    }

if __name__ == '__main__':
    # 使用无限注德州扑克进行6人桌训练
    result = train_deepcfr_6players(
        game_cls=NoLimitHoldem,
        n_iterations=300,
        n_traversals_per_iter=3000,
        mini_batch_size=2048,
        max_buffer_size=2e6,
        save_path="./models/nl_holdem_6p",
        eval_freq=10,
        device_id=0,  # 使用GPU 0，如果没有GPU请使用-1
        verbose=True
    )

    print("训练完成!")
    print(f"最终利用率: {result['exploitability']}")

    # 也可以使用Leduc扑克进行6人桌训练
    """
    result_leduc = train_deepcfr_6players(
        game_cls=StandardLeduc,
        n_iterations=200,
        n_traversals_per_iter=1500,
        mini_batch_size=1024,
        save_path="./models/leduc_6p",
        verbose=True
    )
    """
